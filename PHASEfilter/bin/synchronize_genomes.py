#!/usr/bin/env python3
# encoding: utf-8
'''
best_alignment -- shortdesc

@author:	 mmp

@copyright:  2019 iBiMED. All rights reserved.

@license:	license

@contact:	monsanto@ua.pt

@deffield	updated: Updated
'''
from PHASEfilter.lib.utils.util import Utils
from PHASEfilter.lib.utils.read_gff import ReadGFF
from PHASEfilter.lib.process.process_references import ProcessTwoReferences
from PHASEfilter.lib.utils.software import Software
from PHASEfilter.bin import version
import os, re, sys

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# python3 synchronize_genomes.py
#	--ref1 /usr/local/databases/references/yeast/S288C/S288C_reference_chr_names_cleaned.fna
#	--ref2 /home/projects/ua/rita_guimaraes/syncronizationSacharo/S01.assembly.final.fa 
#	--gff /home/projects/ua/rita_guimaraes/syncronizationSacharo/S01.TE.gff3 
#	--out /home/projects/ua/rita_guimaraes/syncronizationSacharo/result.gff
#   --pass_ref chrmt
from optparse import OptionParser

__all__ = []
__version__ = version.VERSION_synchronize_genomes
__date__ = '2020-05-01'
__updated__ = '2020-05-30'

def checkRequiredArguments(opts, parser):
	missing_options = []
	for option in parser.option_list:
		if re.match(r'^\[REQUIRED\]', option.help) and eval('opts.' + option.dest) == None:
			missing_options.extend(option._long_opts)
	if len(missing_options) > 0:
		parser.error('Missing REQUIRED parameters: ' + str(missing_options))


def main(argv=None):
	'''Command line options.'''
	utils = Utils()
	
	program_name = os.path.basename(sys.argv[0])
	program_version = "{}".format(__version__)
	program_build_date = "%s" % __updated__

	program_version_string = '%%prog %s (%s)' % (program_version, program_build_date)
	#program_usage = '''usage: spam two eggs''' # optional - will be autogenerated by optparse
	program_longdesc = '''''' # optional - give further explanation about what the program does
	program_license = "Copyright 2020 (iBiMED)											\
				Licensed under the MIT\nhttps://spdx.org/licenses/MIT.html"

	if argv is None:
		argv = sys.argv[1:]
	
		# setup option parser
		parser = OptionParser(version=program_version_string, epilog=program_longdesc, description=program_license)
		parser.add_option("--ref1", dest="reference_1", help="[REQUIRED] reference for genome 1", metavar="FILE")
		parser.add_option("--ref2", dest="reference_2", help="[REQUIRED] reference for genome 2", metavar="FILE")
		parser.add_option("--gff", dest="gff", help="[Optional] GFF3 file to set new positions of hit genome (gff3)", metavar="FILE")
		parser.add_option("--vcf", dest="vcf", help="[Optional] VCF file to set new positions of hit genome (vcf)", metavar="FILE")
		parser.add_option("--pass_ref", dest="pass_ref", help="[Optional] name of chromosomes to not processed. More than one chr split by comma, example 'chrI,chrII'")
		parser.add_option("--out", dest="out", help="[REQUIRED] report in tab separated value (tsv)")

		# process options
		(opts, args) = parser.parse_args(argv)
		checkRequiredArguments(opts, parser)
		
		if not opts.gff is None and not opts.vcf is None:
			print("Only one type of file is allowed. You can pass one VCF or one GFF3")
			sys.exit(1)
				
		if opts.reference_1: print("reference 1         = %s" % opts.reference_1)
		if opts.reference_2: print("reference 2         = %s" % opts.reference_2)
		if opts.gff:         print("gff3                = %s" % opts.gff)
		if opts.vcf:         print("vcf                 = %s" % opts.vcf)
		if opts.out:         print("out                 = %s" % opts.out)
		if opts.pass_ref:    print("not processed chr.  = %s" % opts.pass_ref)

		if (opts.reference_1 == opts.reference_2): sys.exit("Error: you have the same reference file")

		utils.test_file_exists(opts.reference_1)
		utils.test_file_exists(opts.reference_2)
		if opts.gff: utils.test_file_exists(opts.gff)
		if opts.vcf: utils.test_file_exists(opts.vcf)
		process_two_references = ProcessTwoReferences(opts.reference_1, opts.reference_2, opts.out)

		### test all software needed to run this script
		software = Software()
		software.test_softwares()

		### parse pass ref
		if (opts.pass_ref): opts.pass_ref = [_.lower() for _ in opts.pass_ref.split(',')]
		else: opts.pass_ref = []
		
		### test output file
		if (os.path.exists(opts.out)):
			read_input = input("Output file '{}' already exist, do you want to replace it? [y|Y] ".format(opts.out))
			if (len(read_input.strip()) > 0 and read_input.upper() != 'Y'): sys.exit("Exit by the user.")

		## make dir if does not exist
		utils.make_path(os.path.dirname(opts.out))
		VECT_TYPE = [ReadGFF.PROCESS_TYPE_all]
		if opts.gff: process_two_references.parse_gff(opts.gff, opts.pass_ref, VECT_TYPE)
		if opts.vcf: process_two_references.parse_vcf(opts.vcf, opts.pass_ref)

		print("File created: {}".format(opts.out))


if __name__ == "__main__":

	sys.exit(main())


